1) При пере- крытии имен при работе с объектом через указатель будет исполняться тот метод, который содержится в классе, используемом в объявлении указателя, независимо от типа объекта, на который указывает указатель.

2) Изврат:
C c1;
C* pc;
pc =	&c1;
pc = (C*)& a1; // Небезопасное преобразование указателя
// на  объект базового класса к  указателю
// на  объект производного класса (данное
// преобразование   должно объявляться
// явно, иначе  – ошибка).
pc -> f(1);	// C::f – несмотря на  то, что pa указывает
// на   объект  а1 типа класс  А. В  общем
// случае  такой  вызов некорректен.

3) Изврат ещё раз!!!
та же фигня. смотреть не только на куда указывют *p, но и слова virtual.

4) p->h & p->h () неоднозначность если сущ. и функция и интовая переменная h.переменная

5) virtual наследование. тоже изврат. ЗАПОмниТЬ.

6) PIZDA. templates; v2009.1
5. template<class T> complex<T> complex<T>::operator*
(const complex<T>& x)
{ complex<T> w; w.r = r * x.r – i * x.i;
w.i = r * x.i + i * x.r; return w; }
template<class T> complex<T> operator*
(const complex<T>& x, const complex<T>& y)
{ complex<T> w; w.r = x.r * y.r – x.i * y.i;
w.i = x.r * y.i + x.i * y.r; return w; };
